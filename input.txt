//  Topics.swift
//  Swift_programming_with_XCode_tutor
//  Updated 7/26/25 – Expanded Swift & Xcode topics

import Foundation
import SwiftUI

enum Topic: String, CaseIterable, Hashable, Identifiable {
    // Swift fundamentals
    case variableKeyword, constantKeyword, optionals, closures, structsVsClasses, protocols
    case generics, functions, enums, errorHandling, accessControl, memoryManagement
    case extensionsFeature, properties, subscripts
    // Advanced language
    case concurrency, propertyWrappers, resultBuilders, actors, distributedActors, asyncLet, taskGroups
    case macros, asyncSequence, patternMatching, typeInference
    // Tooling & packages
    case swiftPackageManager, docc, swiftUI
    // Xcode
    case xcodeProject, interfaceBuilder, xcodeDebugger, unitTesting, instruments, buildSettings
    case sourceControl, signingCapabilities, previews, xcodeCloud, simulators

    var id: String { rawValue }

    var title: String {
        switch self {
        case .variableKeyword:       return "Variables"
        case .constantKeyword:       return "Constants"
        case .optionals:             return "Optionals"
        case .closures:              return "Closures"
        case .structsVsClasses:      return "Structs vs Classes"
        case .protocols:             return "Protocols"
        case .generics:              return "Generics"
        case .functions:             return "Functions"
        case .enums:                 return "Enums"
        case .errorHandling:         return "Error Handling"
        case .accessControl:         return "Access Control"
        case .memoryManagement:      return "Memory Management"
        case .extensionsFeature:     return "Extensions"
        case .properties:            return "Properties"
        case .subscripts:            return "Subscripts"
        case .concurrency:           return "Concurrency"
        case .propertyWrappers:      return "Property Wrappers"
        case .resultBuilders:        return "Result Builders"
        case .actors:                return "Actors"
        case .distributedActors:     return "Distributed Actors"
        case .asyncLet:              return "async let"
        case .taskGroups:            return "Task Groups"
        case .macros:                return "Macros"
        case .asyncSequence:         return "AsyncSequence"
        case .patternMatching:       return "Pattern Matching"
        case .typeInference:         return "Type Inference"
        case .swiftPackageManager:   return "Swift Package Manager"
        case .docc:                  return "DocC"
        case .swiftUI:               return "SwiftUI"
        case .xcodeProject:          return "Xcode Project"
        case .interfaceBuilder:      return "Interface Builder"
        case .xcodeDebugger:         return "Xcode Debugger"
        case .unitTesting:           return "Unit Testing"
        case .instruments:           return "Instruments"
        case .buildSettings:         return "Build Settings"
        case .sourceControl:         return "Source Control"
        case .signingCapabilities:   return "Signing & Capabilities"
        case .previews:              return "Previews"
        case .xcodeCloud:            return "Xcode Cloud"
        case .simulators:            return "Simulators"
        }
    }
}

extension Topic { static var modularAddition: Topic { .variableKeyword } }

struct TopicExplanations {
    private static let map: [Topic: String] = [
        .variableKeyword:       "**Variables** are declared with `var` and are mutable.",
        .constantKeyword:       "**Constants** are declared with `let` and are immutable.",
        .optionals:             "**Optionals** (`?`) allow a value to be either a type or `nil`; they must be safely unwrapped.",
        .closures:              "**Closures** are self-contained blocks of functionality that capture context.",
        .structsVsClasses:      "**Structs** are value types; **classes** are reference types and support inheritance.",
        .protocols:             "**Protocols** define a blueprint of methods/properties that adopting types must implement.",
        .generics:              "**Generics** let you write flexible, reusable code that works with any type.",
        .functions:             "**Functions** declare reusable code blocks with `func`.",
        .enums:                 "**Enums** group related cases into a single type.",
        .errorHandling:         "**Error handling** uses `throw`, `throws`, `try`, and `catch`.",
        .accessControl:         "**Access control** (`open`, `public`, `internal`, `fileprivate`, `private`) controls visibility.",
        .memoryManagement:      "**ARC** automatically manages memory via reference counts.",
        .extensionsFeature:     "**Extensions** add functionality to existing types without subclassing.",
        .properties:            "**Properties** store and compute values; they can be stored or computed.",
        .subscripts:            "**Subscripts** provide shortcut access to collections or custom indexed types.",
        .concurrency:           "**Concurrency** in Swift uses `async`, `await`, actors, and structured tasks.",
        .propertyWrappers:      "**Property wrappers** (`@propertyWrapper`) encapsulate logic for getting/setting values.",
        .resultBuilders:        "**Result builders** enable DSL-style declarative syntax (e.g., SwiftUI).",
        .actors:                "**Actors** are reference types that protect mutable state across concurrency domains.",
        .distributedActors:     "**Distributed actors** enable actor isolation across process or network boundaries.",
        .asyncLet:              "**`async let`** launches concurrent child tasks and awaits their results.",
        .taskGroups:            "**Task groups** create dynamic hierarchies of child tasks with error aggregation.",
        .macros:                "**Macros** perform compile-time code generation and transformations.",
        .asyncSequence:         "**AsyncSequence** produces values asynchronously over time with `for await`.",
        .patternMatching:       "**Pattern matching** (`switch`, `if case`, `guard`) destructures and tests values.",
        .typeInference:         "**Type inference** lets the compiler deduce types, reducing verbosity.",
        .swiftPackageManager:   "**Swift Package Manager** (`swift package`, `Package.swift`) manages dependencies and build.",
        .docc:                  "**DocC** generates API documentation from source-level comments and bundles.",
        .swiftUI:               "**SwiftUI** uses a declarative `View` protocol to build UI across Apple platforms.",
        .xcodeProject:          "**Xcode projects** organize code into targets, schemes, and builds.",
        .interfaceBuilder:      "**Interface Builder** lets you design UI visually (storyboards, XIBs, SwiftUI previews).",
        .xcodeDebugger:         "**Xcode debugger** uses breakpoints and LLDB commands to inspect runtime state.",
        .unitTesting:           "**Unit testing** leverages the `XCTest` framework for assertions and performance tests.",
        .instruments:           "**Instruments** profiles CPU, memory, energy, and more.",
        .buildSettings:         "**Build settings** configure compiler and linker options per target.",
        .sourceControl:         "**Source Control Navigator** integrates Git operations within Xcode.",
        .signingCapabilities:   "**Signing & Capabilities** configures code signing identities and entitlements.",
        .previews:              "**Previews** render SwiftUI views live using `@PreviewProvider`.",
        .xcodeCloud:            "**Xcode Cloud** provides CI/CD pipelines tightly integrated with Xcode and App Store Connect.",
        .simulators:            "**Simulators** emulate Apple devices for testing apps within Xcode."
    ]
    static func text(for t: Topic) -> String { map[t] ?? "" }
}

// The remaining structs and extensions are unchanged.
struct DiscreteMathQuestion: Identifiable, Hashable {
    var id = UUID()
    let question: String
    let answers: [String]
    let correctAnswerIndex: Int
    let explanation: String
    let topic: Topic
}

struct Question: Identifiable, Hashable {
    let id = UUID()
    let prompt: String
    let answer: String
}

enum QuizQuestion: Identifiable, Hashable {
    case multiple(DiscreteMathQuestion)
    case submit(Question)
    var id: UUID { switch self { case .multiple(let q): q.id; case .submit(let q): q.id } }
    var prompt: String { switch self { case .multiple(let q): q.question; case .submit(let q): q.prompt } }
    var isMultipleChoice: Bool { if case .multiple = self { true } else { false } }
    var options: [String]? { if case .multiple(let q) = self { q.answers } else { nil } }
    var solution: String { switch self {
        case .multiple(let q): q.answers[q.correctAnswerIndex]
        case .submit(let q):   q.answer } }
}

extension Topic {
    func generated() -> DiscreteMathQuestion {
        switch self {
        case .variableKeyword:       return QuestionGenerator.variableKeywordQuestion()
        case .constantKeyword:       return QuestionGenerator.constantKeywordQuestion()
        case .optionals:             return QuestionGenerator.optionalsQuestion()
        case .closures:              return QuestionGenerator.closuresQuestion()
        case .structsVsClasses:      return QuestionGenerator.structsVsClassesQuestion()
        case .protocols:             return QuestionGenerator.protocolsQuestion()
        case .generics:              return QuestionGenerator.genericsQuestion()
        case .functions:             return QuestionGenerator.functionsQuestion()
        case .enums:                 return QuestionGenerator.enumsQuestion()
        case .errorHandling:         return QuestionGenerator.errorHandlingQuestion()
        case .accessControl:         return QuestionGenerator.accessControlQuestion()
        case .memoryManagement:      return QuestionGenerator.memoryManagementQuestion()
        case .extensionsFeature:     return QuestionGenerator.extensionsFeatureQuestion()
        case .properties:            return QuestionGenerator.propertiesQuestion()
        case .subscripts:            return QuestionGenerator.subscriptsQuestion()
        case .concurrency:           return QuestionGenerator.concurrencyQuestion()
        case .propertyWrappers:      return QuestionGenerator.propertyWrappersQuestion()
        case .resultBuilders:        return QuestionGenerator.resultBuildersQuestion()
        case .actors:                return QuestionGenerator.actorsQuestion()
        case .distributedActors:     return QuestionGenerator.distributedActorsQuestion()
        case .asyncLet:              return QuestionGenerator.asyncLetQuestion()
        case .taskGroups:            return QuestionGenerator.taskGroupsQuestion()
        case .macros:                return QuestionGenerator.macrosQuestion()
        case .asyncSequence:         return QuestionGenerator.asyncSequenceQuestion()
        case .patternMatching:       return QuestionGenerator.patternMatchingQuestion()
        case .typeInference:         return QuestionGenerator.typeInferenceQuestion()
        case .swiftPackageManager:   return QuestionGenerator.swiftPackageManagerQuestion()
        case .docc:                  return QuestionGenerator.doccQuestion()
        case .swiftUI:               return QuestionGenerator.swiftUIQuestion()
        case .xcodeProject:          return QuestionGenerator.xcodeProjectQuestion()
        case .interfaceBuilder:      return QuestionGenerator.interfaceBuilderQuestion()
        case .xcodeDebugger:         return QuestionGenerator.xcodeDebuggerQuestion()
        case .unitTesting:           return QuestionGenerator.unitTestingQuestion()
        case .instruments:           return QuestionGenerator.instrumentsQuestion()
        case .buildSettings:         return QuestionGenerator.buildSettingsQuestion()
        case .sourceControl:         return QuestionGenerator.sourceControlQuestion()
        case .signingCapabilities:   return QuestionGenerator.signingCapabilitiesQuestion()
        case .previews:              return QuestionGenerator.previewsQuestion()
        case .xcodeCloud:            return QuestionGenerator.xcodeCloudQuestion()
        case .simulators:            return QuestionGenerator.simulatorsQuestion()
        }
    }
    func randomQuestion() -> Question {
        let q = generated()
        return Question(prompt: q.question, answer: q.answers[q.correctAnswerIndex])
    }
    func mixedQuestion() -> QuizQuestion {
        Bool.random() ? .multiple(generated()) : .submit(randomQuestion())
    }
    var explanation: String { TopicExplanations.text(for: self) }
    var short: String { String(title.prefix(12)) }
    func answer(for _: String) -> String { "\(explanation)\n\n(For full details, ask about a concrete example.)" }
}

struct QuizFactory {
    static func generate(count: Int = 20) -> [QuizQuestion] {
        var out: [QuizQuestion] = []
        var topics = Topic.allCases.shuffled()
        while out.count < count {
            if topics.isEmpty { topics = Topic.allCases.shuffled() }
            out.append(topics.removeFirst().mixedQuestion())
        }
        return out.shuffled()
    }
}

//  QuestionGenerator.swift
//  Swift_programming_with_XCode_tutor
//  Updated 7/26/25 – Expanded Swift & Xcode questions

import Foundation

enum QuestionGenerator {
    static let maxCount = 200

    private static func make(_ q: String,
                             _ opts: [String],
                             _ correct: Int,
                             _ expl: String,
                             _ top: Topic) -> DiscreteMathQuestion {
        DiscreteMathQuestion(
            question: q,
            answers: opts,
            correctAnswerIndex: correct,
            explanation: expl,
            topic: top)
    }

    // Swift fundamentals
    static func variableKeywordQuestion() -> DiscreteMathQuestion {
        make("Which keyword declares a mutable variable in Swift?",
             ["var", "let", "func", "enum"], 0,
             "`var` declares a variable whose value can change.", .variableKeyword)
    }
    static func constantKeywordQuestion() -> DiscreteMathQuestion {
        make("Which keyword declares an immutable constant?",
             ["let", "var", "static", "mutating"], 0,
             "`let` creates a constant that cannot be reassigned.", .constantKeyword)
    }
    static func optionalsQuestion() -> DiscreteMathQuestion {
        make("An optional in Swift represents …?",
             ["A value that may be nil", "A generic type", "A type alias", "A protocol"], 0,
             "Optionals wrap a value that can be present or `nil`.", .optionals)
    }
    static func closuresQuestion() -> DiscreteMathQuestion {
        make("In Swift, a closure is …?",
             ["A self-contained block of code", "A stored property", "A protocol extension", "A generic constraint"], 0,
             "Closures are anonymous functions that can capture surrounding context.", .closures)
    }
    static func structsVsClassesQuestion() -> DiscreteMathQuestion {
        make("Which statement about structs and classes is correct?",
             ["Classes support inheritance", "Structs support inheritance", "Both are reference types", "Only structs have deinitializers"], 0,
             "Classes are reference types and can inherit; structs are value types.", .structsVsClasses)
    }
    static func protocolsQuestion() -> DiscreteMathQuestion {
        make("What does a protocol provide in Swift?",
             ["Blueprint of methods and properties", "A concrete data type", "A way to handle errors", "A compile-time attribute"], 0,
             "Protocols define requirements adopted by types.", .protocols)
    }
    static func genericsQuestion() -> DiscreteMathQuestion {
        make("Generics in Swift enable …?",
             ["Code that works with any type", "Runtime reflection", "Automatic memory management", "Dynamic dispatch only"], 0,
             "Generics let you write flexible, reusable code that works with any type.", .generics)
    }
    static func extensionsFeatureQuestion() -> DiscreteMathQuestion {
        make("Extensions in Swift allow you to …?",
             ["Add new functionality to existing types", "Create new protocols", "Allocate memory manually", "Define new access levels"], 0,
             "Extensions add methods, properties, or conformance without subclassing.", .extensionsFeature)
    }
    static func propertiesQuestion() -> DiscreteMathQuestion {
        make("Which property stores a new value every time and doesn’t compute on access?",
             ["Stored property", "Computed property", "Lazy property", "Type property"], 0,
             "Stored properties keep values directly; computed properties calculate on access.", .properties)
    }
    static func subscriptsQuestion() -> DiscreteMathQuestion {
        make("The `subscript` keyword enables …?",
             ["Indexed access like array[key]", "Protocol conformance", "Generics specialization", "Automatic memory management"], 0,
             "Subscripts give shortcut access to collection-like types.", .subscripts)
    }
    static func concurrencyQuestion() -> DiscreteMathQuestion {
        make("Swift concurrency is primarily expressed with …?",
             ["`async` and `await`", "`goto` statements", "Polling loops", "Global locks only"], 0,
             "Structured concurrency uses `async`/`await` and task groups.", .concurrency)
    }

    // Additional Swift topics
    static func functionsQuestion() -> DiscreteMathQuestion {
        make("Which keyword defines a function in Swift?",
             ["func", "fun", "def", "function"], 0,
             "`func` introduces a reusable function.", .functions)
    }
    static func enumsQuestion() -> DiscreteMathQuestion {
        make("Which keyword declares an enumeration?",
             ["enum", "struct", "case", "option"], 0,
             "`enum` defines a type with multiple cases.", .enums)
    }
    static func errorHandlingQuestion() -> DiscreteMathQuestion {
        make("Which keyword marks a Swift function that can throw an error?",
             ["throws", "throw", "try", "catch"], 0,
             "`throws` indicates a function may propagate errors.", .errorHandling)
    }
    static func accessControlQuestion() -> DiscreteMathQuestion {
        make("What is the most permissive access level in Swift?",
             ["open", "public", "internal", "private"], 0,
             "`open` allows use and subclassing outside the defining module.", .accessControl)
    }
    static func memoryManagementQuestion() -> DiscreteMathQuestion {
        make("Swift uses which memory-management model?",
             ["Automatic Reference Counting (ARC)", "Garbage Collection", "Manual Reference Counting", "Region-based Allocation"], 0,
             "ARC automatically manages object lifetimes via reference counts.", .memoryManagement)
    }

    // Advanced language
    static func propertyWrappersQuestion() -> DiscreteMathQuestion {
        make("Which attribute defines a property wrapper?",
             ["@propertyWrapper", "@wrapper", "@property", "@delegate"], 0,
             "`@propertyWrapper` creates reusable get/set behavior.", .propertyWrappers)
    }
    static func resultBuildersQuestion() -> DiscreteMathQuestion {
        make("Result builders in Swift enable …?",
             ["Declarative DSL syntax", "Reference counting", "Error handling", "Memory copying"], 0,
             "Result builders transform block syntax into chained calls (e.g., SwiftUI).", .resultBuilders)
    }
    static func actorsQuestion() -> DiscreteMathQuestion {
        make("An `actor` in Swift is …?",
             ["A reference type isolating mutable state", "A compile-time macro", "A value type for animations", "An Objective-C class"], 0,
             "Actors serialize access to their internal state across tasks.", .actors)
    }
    static func distributedActorsQuestion() -> DiscreteMathQuestion {
        make("Distributed actors differ from regular actors by …?",
             ["Isolating state across process or network boundaries", "Allowing subclass inheritance", "Requiring Objective-C runtime", "Disabling async/await"], 0,
             "Distributed actors communicate securely across boundaries.", .distributedActors)
    }
    static func asyncLetQuestion() -> DiscreteMathQuestion {
        make("`async let` is used to …?",
             ["Start a child task concurrently", "Define a constant", "Handle errors", "Create a macro"], 0,
             "`async let` launches a child task and binds its result.", .asyncLet)
    }
    static func taskGroupsQuestion() -> DiscreteMathQuestion {
        make("Task groups in Swift enable …?",
             ["Dynamic, structured spawning of child tasks", "Global locks", "Manual thread pools", "Blocking synchronization"], 0,
             "Task groups run many tasks concurrently and gather results.", .taskGroups)
    }
    static func macrosQuestion() -> DiscreteMathQuestion {
        make("Swift macros provide …?",
             ["Compile-time code generation", "Just-in-time compilation", "Manual memory management", "Exclusive Objective-C interop"], 0,
             "Macros expand source code during compilation for boilerplate reduction.", .macros)
    }
    static func asyncSequenceQuestion() -> DiscreteMathQuestion {
        make("An `AsyncSequence` differs from `Sequence` because …?",
             ["It delivers values asynchronously over time", "It works only with arrays", "It runs only on main thread", "It cannot throw errors"], 0,
             "`AsyncSequence` integrates with `for await` to consume values asynchronously.", .asyncSequence)
    }
    static func patternMatchingQuestion() -> DiscreteMathQuestion {
        make("The `_` symbol in a `switch` case represents …?",
             ["A wildcard pattern", "A default enum case", "Nil coalescing", "Type erasure"], 0,
             "Wildcard `_` matches any remaining values.", .patternMatching)
    }
    static func typeInferenceQuestion() -> DiscreteMathQuestion {
        make("Type inference in Swift allows …?",
             ["Omitting explicit type annotations", "Runtime reflection only", "Dynamic typing", "Skipping compilation"], 0,
             "The compiler deduces types from context.", .typeInference)
    }
    static func swiftPackageManagerQuestion() -> DiscreteMathQuestion {
        make("Dependencies in Swift Package Manager are declared in …?",
             ["Package.swift", "Podfile", "Cartfile", "build.gradle"], 0,
             "`Package.swift` defines products, targets, and dependencies.", .swiftPackageManager)
    }
    static func doccQuestion() -> DiscreteMathQuestion {
        make("DocC is primarily used to …?",
             ["Generate API documentation", "Manage code signing", "Debug LLDB sessions", "Profile performance"], 0,
             "DocC converts Markdown comments into HTML documentation.", .docc)
    }
    static func swiftUIQuestion() -> DiscreteMathQuestion {
        make("In SwiftUI, UI is defined using …?",
             ["Structs conforming to `View`", "Storyboards", "XIBs", "Nib files"], 0,
             "SwiftUI views are value-type structs with declarative syntax.", .swiftUI)
    }

    // Xcode topics
    static func xcodeProjectQuestion() -> DiscreteMathQuestion {
        make("A single Xcode project can contain one or more …?",
             ["targets", "schemes", "workspaces", "packages"], 0,
             "Targets compile code/products like apps or frameworks.", .xcodeProject)
    }
    static func interfaceBuilderQuestion() -> DiscreteMathQuestion {
        make("Which Xcode component lets you design UI visually?",
             ["Interface Builder", "Instruments", "Source Control Navigator", "Console"], 0,
             "Interface Builder works with storyboards, XIBs, and SwiftUI previews.", .interfaceBuilder)
    }
    static func xcodeDebuggerQuestion() -> DiscreteMathQuestion {
        make("To pause execution at a specific line in Xcode you set a …?",
             ["breakpoint", "checkpoint", "anchor", "flag"], 0,
             "Breakpoints let you inspect state at runtime.", .xcodeDebugger)
    }
    static func unitTestingQuestion() -> DiscreteMathQuestion {
        make("Which framework is used for unit testing in Xcode?",
             ["XCTest", "JUnit", "Mocha", "NUnit"], 0,
             "`XCTest` provides assertions, expectations, and test runners.", .unitTesting)
    }
    static func instrumentsQuestion() -> DiscreteMathQuestion {
        make("The Instruments Time Profiler tool is primarily used to analyze …?",
             ["CPU usage", "Memory leaks", "Network traffic", "Energy impact"], 0,
             "Time Profiler samples stacks to measure CPU hotspots.", .instruments)
    }
    static func buildSettingsQuestion() -> DiscreteMathQuestion {
        make("Compiler and linker flags are configured in Xcode's …?",
             ["Build Settings tab", "General tab", "Info tab", "Build Phases tab"], 0,
             "The Build Settings tab exposes granular configuration for each target.", .buildSettings)
    }
    static func sourceControlQuestion() -> DiscreteMathQuestion {
        make("Which navigator shows commit history in Xcode?",
             ["Source Control Navigator", "Debug Navigator", "Issue Navigator", "Trace Navigator"], 0,
             "Source Control Navigator integrates Git operations.", .sourceControl)
    }
    static func signingCapabilitiesQuestion() -> DiscreteMathQuestion {
        make("Code signing identities are configured in Xcode's …?",
             ["Signing & Capabilities tab", "General tab", "Build Settings", "Preview canvas"], 0,
             "Signing & Capabilities manages certificates and entitlements.", .signingCapabilities)
    }
    static func previewsQuestion() -> DiscreteMathQuestion {
        make("SwiftUI previews rely on types conforming to …?",
             ["PreviewProvider", "Scene", "App", "ObservableObject"], 0,
             "`PreviewProvider` supplies sample views for live rendering.", .previews)
    }
    static func xcodeCloudQuestion() -> DiscreteMathQuestion {
        make("Xcode Cloud primarily provides …?",
             ["Continuous integration and delivery", "Memory profiling", "Visual UI design", "Static code analysis"], 0,
             "Xcode Cloud automates building, testing, and distributing apps.", .xcodeCloud)
    }
    static func simulatorsQuestion() -> DiscreteMathQuestion {
        make("Xcode Simulators let you …?",
             ["Run apps on virtual devices", "Generate documentation", "Upload builds to TestFlight", "Edit storyboards"], 0,
             "Simulators emulate hardware and OS versions for testing.", .simulators)
    }
}
